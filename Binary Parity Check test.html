<!DOCTYPE HTML>
<html id='html'>
<style>
html{
background-color: black;
color: silver;
}
</style>
<body>
<h1><b>Parity Testing [LIVE]: </b></h1>
<textarea id='here' oninput='this.innerHTML=this.value;work();' style='align:center;width:78vw;height:15vw;padding:2vw;margin:2vw;align:center;'  placeholder='Type to see what you get...'></textarea>

<p id='output'></p>

</body>

<script>
	 
function work(){
var getit = document.getElementById('here').value;
var jim = '', dooby = ''; goody = '', gary = 0, carol = 1;



	var r1 = [], r2 = [], r3 = [], r4 = [], zero = [], whem = [], rar1 = 0, rar2 = 0, rar3 = 0, rar4 = 0, rar5 = 0, gwom = 0, gewm = 1, gew = 1, gex = 2, gez = 3, gwet = 7, xwem = 2, goo = 0, gru = 0, gool = 0, goot = 0, pd1 = '';
	
	var st1 = [], st2 = [], st3 = [], st4 = [], st5 = [], st0 = [], st6 = [], note1 = '', note2 = '', note3 = '', note4 = '', note0 = '', note5 = '', note6 = '';

    var	ad1 = [], ad2 = [], ad3 = [], ad4 = [], ad5 = [], ad6 = [], gg1 = [], gg2 = [], gg3 = [], gg4 = [], s1pos = [], s2pos = [], s3pos = [], s4pos = [], s5pos = [], s6pos = [];
	
	var d1 = [], d2 = [], d3 = [], d4 = [], d0 = [], oof = 0;
	
	var smith = 4, stan = 8, smith2 = 4, stan2 = 8;
	 

for (var i = 0; i < getit.length; i++) {
      dooby = getit[i].charCodeAt(0).toString(2);
     goody = parseInt(dooby, 2).toString().replace(/(\.|\+|\D)/g, ''); //decimal output
	//  goody = dooby.toString().replace(/(\.|\+|\D)/g, ''); //binary output
  jim = jim + "" + Math.ceil(Math.trunc(Number(goody) * 3.14) + goody.length) % 2;
}
  
<!-- below is testing accuracy of my 7,4 haming code implication in js -->

//getting repeating bits from the active changing of input even just upward (no removal)



	 <!-- ree === gewm (0)
	 <!-- ref === gew (1)
	 <!-- ret === gex (2)
	 <!-- reg === gez (3)
	 <!-- rey === gwet (7)
	 
	 <!-- node# will be Detector arrays for determining the detectors for the graphing -->
	 
	      <!-- gwom is the averge cut to find the longest array, longest array sets loop max-scale-limit (how many times we can multiply xwem by longest array base to catch all points) -->
	var garry = jim.length;
	var notjim = jim;
	
	 for(var king = 1; king <= garry; king = king+2){ //Question 1
	  st1.push(jim[king]);
	  
	  if(jim[king] == 1){
	   s1pos.push(king);
	  }
	  
	 }
	 
	 for(var queen = 2; queen <= garry; queen = queen+1){ //Question 2
	  st2.push(jim[queen]);
	  
	  if(jim[queen] == 1){
	   s2pos.push(queen);
	  }
	  
	  if(queen%2 != 0){
	   queen = queen +2;
	  }
	 }
	 
	 for(var jack = 4; jack <= garry; jack = jack+1){ //Question 3
	  st3.push(jim[jack]);
	  smith = smith - 1;
	  
	  if(jim[jack] == 1){
	   s3pos.push(jack);
	  }
	  
	  
	 if(smith === 0){
	   jack = jack + 4;
	   smith = 4;
	  }
	 }
	 
	 for(var rook = 8; rook <= garry; rook = rook+1){ //Question 4
	  st4.push(jim[rook]);
	  stan = stan - 1;
	  
	  if(jim[rook] == 1){
	   s4pos.push(rook);
	  }
	  
	  
	 if(stan === 0){
	   rook = rook + 8;
	   stan = 8;
	  }
	 }
	 
	 for(var blossom = 0; blossom <= garry; blossom = blossom+2){ //Flower Q5
	  st5.push(jim[blossom]);
	  stan = stan - 1;
	  
	  if(jim[blossom] == 1){
	   s5pos.push(blossom);
	  }
	  
	 }
	 
	 for(var bubbles = 0; bubbles <= garry; bubbles = jack+1){ //Flower Q6
	  st6.push(jim[bubbles]);
	  smith = smith - 1;
	  
	  if(jim[bubbles] == 1){
	   s6pos.push(bubbles);
	  }
	  
	  
	 if(smith === 0){
	   bubbles = bubbles + 4;
	   smith = 4;
	  }
	 }
	 
	
	  <!-- find all the 1's for comparison -->
	 note1 = st1.toString().match(/1/g), note2 = st2.toString().match(/1/g), note3 = st3.toString().match(/1/g), note0 = st4.toString().match(/1/g); 
	 
	 <!-- this section of note# === null doesn't seem to do as intended but when this part is removed, stuff doesn't work right so here it is -->
	 if(note1 === null || note1 === ''){
	  note1 = 0;
	 }
	 if(note2 === null || note2 === ''){
	  note2 = 0;
	 }
	 if(note3 === null || note3 === ''){
	  note3 = 0;
	 }
	 if(note0 === null || note0 === ''){
	  note0 = 0;
	 } 
	 
	  <!-- find the length of total 1's in string -->
	 note1 = note1.length, note2 = note2.length, note3 = note3.length, note0 = note0.length;
	 
	 
	 if((note1%2) == 0){ <!-- if divisible by 2, it's even -->
	  d1.push(0);
	 } 
	 else{
	  d1.push(1);
	 }
	 
	 if((note2%2) == 0){ <!-- if divisible by 2, it's even -->
	  d2.push(0);
	 } 
	 else{
	  d2.push(1);
	 } 
	 
	 if((note3%2) == 0){ <!-- if divisible by 2, it's even -->
	  d3.push(0);
	 }  
	 else{
	  d3.push(1);
	 }
	 
	 if((note0%2) == 0){ <!-- if divisible by 2, it's even -->
	  d4.push(0);
	 } 
	 else{
	  d4.push(1);
	 } 
	 
	 <!-- begin testing advanced checks -->
	 
	 var diana = st1.toString().match(/1/gm);
     var diann = st2.toString().match(/1/gm);
	 
	ad1.push((Math.abs(diana ^ diann) >>> 0).toString(2));
	//ad1.push("&"+""+diana);
	//ad1.push("$"+""+diann); <!--debuggers-->
	
	if(ad1[0] !== 0){
	
	 if(ad1[0].toString().length > 1){
	  ad4[carol] = ad1[0]; 
	carol = carol + 1; <!-- moves the next potential error to new slot in array -->
	
	 }
	 
	 if(ad1[0] == 1 && diana.length > 0){
	  ad4[0] = s1pos[0] ^ s1pos[1]; <!-- sets the first blob-drop -->
	  var ft = 2; <!-- looking for 3rd item in array -->
	 
	  for(var sarah = 0; sarah < s1pos.length; sarah++){ <!-- based on original s1pos length (should have 1 overlay maybe 2 with silence or null (this may cause data residue) ) -->
	   var swif = ad4[0]; <!-- sets blob-drop for next drop -->
	   ad4[0] = s1pos[ft] ^ swif; <!-- xor -->
	   ft = ft + 1; <!-- set for moving forward -->
	  }
	  
	ad4[carol] = Math.abs(ad4[0] >>> 0).toString(2); <!-- we only want to do this with the null'd object because ad4 also stores potential error locations  -->
	carol = carol + 1; <!-- moves the next potential error to new slot in array -->
	
 	 }<!-- ad4 past the null object are the potential errors location(s) -->
	 
	} 
	
	var kjeet = st3.toString().match(/1/gm);
	var jdeet = st4.toString().match(/1/gm);
	 
	 ad2.push((Math.abs(kjeet ^ jdeet) >>> 0).toString(2));
	 
	 
	if(ad2[0] !== 0){
	
	 if(ad2[0].toString().length > 1){
	  ad3[carol] = ad2[0]; 
	carol = carol + 1; <!-- moves the next potential error to new slot in array -->
	
	 }
	 
	 if(ad2[0] == 1 && kjeet.length > 0){
	  ad3[0] = s2pos[0] ^ s2pos[1]; <!-- sets the first blob-drop -->
	  var ft = 2; <!-- looking for 3rd item in array -->
	 
	  for(var sarah = 0; sarah < s2pos.length; sarah++){ <!-- based on original s1pos length (should have 1 overlay maybe 2 with silence or null (this may cause data residue) ) -->
	   var swif = ad3[0]; <!-- sets blob-drop for next drop -->
	   ad3[0] = s2pos[ft] ^ swif; <!-- xor -->
	   ft = ft + 1; <!-- set for moving forward -->
	  }
	  
	ad3[carol] = Math.abs(ad3[0] >>> 0).toString(2); <!-- we only want to do this with the null'd object because ad3 also stores potential error locations  -->
	carol = carol + 1; <!-- moves the next potential error to new slot in array -->
	
 	 }<!-- ad3 past the null object are the potential errors location(s) -->
	 
	} 
	
	var crystal = st5.toString().match(/1/gm);
	var kris = st6.toString().match(/1/gm);
	 
	 ad5.push((Math.abs(crystal ^ kris) >>> 0).toString(2));
	 
	 
	if(ad5[0] !== 0){
	
	 if(ad5[0].toString().length > 1){
	  ad6[carol] = ad5[0]; 
	carol = carol + 1; <!-- moves the next potential error to new slot in array -->
	
	 }
	 
	 if(ad5[0] == 1 && crystal.length > 0){
	  ad6[0] = s3pos[0] ^ s3pos[1]; <!-- sets the first blob-drop -->
	  var ft = 2; <!-- looking for 3rd item in array -->
	 
	  for(var sarah = 0; sarah < s3pos.length; sarah++){ <!-- based on original s3pos length (should have 1 overlay maybe 2 with silence or null (this may cause data residue) ) -->
	   var swif = ad6[0]; <!-- sets blob-drop for next drop -->
	   ad6[0] = s3pos[ft] ^ swif; <!-- xor -->
	   ft = ft + 1; <!-- set for moving forward -->
	  }
	  
	ad6[carol] = Math.abs(ad6[0] >>> 0).toString(2); <!-- we only want to do this with the null'd object because ad6 also stores potential error locations  -->
	carol = carol + 1; <!-- moves the next potential error to new slot in array -->
	
 	 }<!-- ad6 past the null object are the potential errors location(s) -->
	 
	} 
	
	 
	 if((note1^note2^note3^note4) === 1){ <!--mains parity check -->
	  gg1.push(0);
	 }
	 else{
	  gg1.push(1);
	 }
	 
	 if((d1^d2^d3^d4) === 1){ <!-- determiner's pairty check -->
	  gg2.push(0);
	 }
	 else{
	  gg2.push(1);
	 }
	 
	 if((note1^d1^note2^d2^note3^d3^note4^d4) === 1){ <!-- "full parity check" -->
	  gg3.push(0);
	 }
	 else{
	  gg3.push(1);
	 }
	 
	 if((note1^d1^note2^d2^note3^d3^note4^d4^note5^note6) === 1){ <!-- "flower check" -->
	  gg4.push(0);
	 }
	 else{
	  gg4.push(1);
	 }


<!-- above is added parity check (7,4) Hamming code testing for correcting correctness -->

// style='align:center;text-align:center;'
document.getElementById('output').innerHTML = "</br>Binary&nbsp;Rep&nbsp;Bit:&nbsp;" + Math.ceil(Math.trunc(Number(jim) * 3.14) + jim.length) % 2 +"</br>Length of input:&nbsp;" + jim.length + "</br>Decimal&nbsp;Input:&nbsp;<b style='word-break:break-word;'> >---{&nbsp;" + jim + "&nbsp;}----></b>&nbsp;</br><hr></br>Check&nbsp;1:&nbsp;" + st1 + "&nbsp;[&nbsp;" + note1 + "&nbsp;&nbsp;|&nbsp;&nbsp;" + d1 + "]<-- Determiner</br><hr></br>Live&nbsp;Bits:&nbsp;" + s1pos + 
"</br><hr></br>Check&nbsp;2:&nbsp;" + st2 + "&nbsp;[&nbsp;" + note2 + "&nbsp;&nbsp;|&nbsp;&nbsp;" + d2 + "]<-- Determiner</br><hr></br>Live&nbsp;Bits:&nbsp;" + s2pos + 
"</br><hr></br>Check&nbsp;3:&nbsp;" + st3 + "&nbsp;[&nbsp;" + note3 + "&nbsp;&nbsp;|&nbsp;&nbsp;" + d3 + "]<-- Determiner</br><hr></br>Live&nbsp;Bits:&nbsp;" + s3pos + 
"</br><hr></br>Check&nbsp;4:&nbsp;" + st4 + "&nbsp;[&nbsp;" + note0 + "&nbsp;&nbsp;|&nbsp;&nbsp;" + d4 + "]<-- Determiner</br><hr></br>Live&nbsp;Bits:&nbsp;" + s4pos + 
"</br><hr></br>Check&nbsp;Mains:&nbsp;" + ad1 + "</br>Error&nbsp;(mains):&nbsp;" + ad4 + "</br></br>Check&nbsp;Subs:&nbsp;" + ad2 + "</br>Error&nbsp;(subs):&nbsp;" + ad3 + "</br></br>Check&nbsp;Flower:&nbsp;" + ad5 + "</br>Error&nbsp;(flower):&nbsp;" + ad6 + "</br><hr></br>Mains's&nbsp;Pairty Bit:&nbsp;" + gg1 + "</br>Determiner's&nbsp;Pairty Bit:&nbsp;" + gg2 + "</br>Full&nbsp;Pairty&nbsp;Bit:&nbsp;" + gg3 + "</br>Flower's&nbsp;Parity Bit:&nbsp;" + gg4 + "</br><hr></br>";
}
</script>
</html>
